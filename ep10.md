_38:24_ `Text.Regex.Applicative`

Пример с foldl может быть не такой убедительный, потому что foldl нам никогда не нужен, нам всегда нужен foldl'. Но похожий пример и, о котором я, например, очень волнуюсь - у меня есть такая библиотека [regex-applicative]. Это регулярные выражения с аппликативным интерфейсом. То есть вы пишите парсер-комбинаторы аппликативные и они работают, как регулярные выражения, а не как бэктреккинг-парсеры. И там возникает вопрос - мы промежуточные результаты вычисляем строго, энергично или мы всё откладываем до конца? По умолчанию, когда вы работаете практически с любыми аппликативными функторами, вычисления откладываются до конца. То есть, когда вы используете `<$>`, `<*>` вы строите, строите это вычисление, оно ни в какой момент, до самого конца, не будет форсировано. Это, конечно, неприятно. Особенно с парсерами, которые могут потреблять очень много информации, аккумулировать очень большие санки. Почему так делается? Ну, во-первых, из-за ленивости программистов. Это же надо всё везде форсировать. Во-вторых из-за того, что это не всегда хорошо и правильно. Не всегда это желаемая семантика. Например в [regex-applicative] идёт не бэктреккинг, а там идёт поиск в ширину. То есть там все ветки проходятся одновременно и из-за этого, если вы будете слишком энергично всё форсировать, то что получится? У вас, например, в одной ветке вылетит эксепшн и он убьёт весь парсер, а на самом деле эта ветка должна будет потом умереть и до конца она не доживёт. И если бы вы её не вычисляли, то ваш парсер дожил бы до конца. То есть там ленивость может быть желаема с точки зрения семантики. И, наконец, третья причина состоит в том, что если мы будем форсировать результат, то мы, я подозреваю, нарушим законы функторов. Это, конечно, причина такая, полусильная, но всё равно неприятно, если мы нарушим законы функторов. Давайте придумаем какой-нибудь пример. Я думаю, что с каким-нибудь `fmap id` что-нибудь сломается, что-то в таком духе. Надо подумать.

[regex-applicative]: https://github.com/feuerbach/regex-applicative
